##题目

[Intervals](http://acm.zjut.edu.cn/ShowProblem.aspx?ShowID=1149)

##分析

s[i]：表示从0到i之间出现的元素的个数，则[a,b]之间有至少有c个元素可以表示成`s[b+1]-s[a]>=c`,实际上表示的区间为[a+1,b+1]，但可以都在原有的基础上减-1，相当于下标从-1开始，也就是是实际上表示的值都求出值减去1即可。

求输入的区间右边界b的最大值加1为maxv，则最后只要求s[maxv]即可

`1>=s[j+1]-s[j]>=0`可以写成`s[j+1]-s[j]>=0`从j到j+1有一条长度为0的边，如果`s[j+1]<s[j]`，现在到j+1结点并不是最长的，通过j结点然后到达j+1结点才是最长的，所以需要更新，首先需要更新j结点来更新j+1结点

`s[j]-s[j+1]>=-1`从j+1到j有一条长度为-1的结点，如果`s[j]<s[j+1]-1`，则说明经过j+1点到达j点的路径会更长一些，所以需要更新，首先经过j+1再到达j结点，因为j的更新要依据j+1结点，所以新更新大的再更新小的

`<=`是最短路径；`>=`是最长路径

当`s[j]+1<s[j+1]`时，更新`s[j]=s[j+1]-1`，从大到小遍历（以最大为标准，从大到小更新）

当`s[j-1]>s[j]`时，`s[j]=s[j-1]`，从小到大遍历（以最小的为基准，从小到大更新）

如果更新的时候完全没有变化了，则退出循环。

##重要代码

```
bool flag=1;
//while循环这段是重点
while(flag)
{
    flag=0;
    for(int i=0;i<n;i++)
    {
        if(s[ns[i].b]<s[ns[i].a]+ns[i].c)
        {
            s[ns[i].b]=s[ns[i].a]+ns[i].c;
            flag=1;
        }    
    }
    //从大到小遍历
    for(int i=maxv;i;i--)
    {
        //这条满足s[i-1]-s[i]>=-1这条不等式
        if(s[i]>s[i-1]+1)
        {
            s[i-1]=s[i]-1;
        }
    }
    //从小到大遍历
    for(int i=1;i<=maxv;i++)
    {
        if(s[i]<s[i-1])
        {
            s[i]=s[i-1];
        }
    }
    
}
```
