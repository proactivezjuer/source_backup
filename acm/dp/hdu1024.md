##题目

[Max Sum Plus Plus](http://acm.hdu.edu.cn/showproblem.php?pid=1024)

##解析

题目意思：m段不相交子段和，求最大值

可以得到公式 `dp[i][j] = max(dp[i-1][j]`, `maxj-1<=t<=i-1(dp[t][j-1]))`，`dp[i][j]`表示的意思是i个数字分成j段并且包含`a[i]`的最大值，然后只要遍历所有的`dp[i][m]`就可以得到最大的m段子段和了。`dp]i][j]`需要包含`a[i]`是为了dp过程简单，而且证明也是正确的，因为最后的结果肯定会包含在`dp[t][m]`, `m<=t<=n`之中
 
因为n非常大，`m<=n`也可以非常大，所以`dp[n][m]`肯定会超内存，要用一维数组去模拟二维数组

因为最外层是一个for循环，for循环是对数字的一个个遍历，所以可以把for循环中的一个一维数组`f[j]`去模拟`dp[i][j]`，需要比较`dp[i-1][j]`和`dp[t][j-1](j-1<=t<=i-1)`，所以需要把最大的`dp[t][j-1](j-1<=t<=i-1)`记录下来，用一个`best[j-1]`数组即可，因为当前计算出来的`f[j]`需要和`best[j]`进行比较并且动态的改变`best[j]`，但是for循环的下一次比较中又要用到`best[j]`，所以需要有两个`best[j]`数组，一个用于比较，一个用于动态更新，一个遍历结束之后把动态变化的部分重新赋值给需要比较的数组（这是常用的方法，需要比较，又需要动态更新的数组，就开辟两个一样的数组，一个用于动态更新，一个用于比较，一次比较完成之后，把动态更新的数组赋值给比较的数组，以便开始下一次的比较）
 
因为每个for循环开始的时候`best[1][i]`都没有赋值，所以需要手动赋值，以方便得到`f[i]`之后可以比较`f[i]`和`best[1][i]`，然后对`best[1][i]`进行赋值，那么开始应该赋值多少呢，应该赋值负无穷而不是0，因为`f[i]`得到有可能是负数，如果是0，反而比`f[i]`大了，而实际情况是第一次得到`f[i]`肯定要赋值给`best[1][i]`的。

当i==j时，即段数等于数字的长度时，肯定是每一个数字表示一段，那么f[i]==sum(0,i-1)了

大部分的二维dp可以化成一维的，这种`best[2][m]`的数组经常会用到`best[0][m]`用于比较，`best[1][m]`用于动态更新，记录下一次比较的情况，当前遍历结束之后就把`best[1][m]`赋值给`best[0][m]`
