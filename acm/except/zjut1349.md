##题目

[掷硬币](http://acm.zjut.edu.cn/ShowProblem.aspx?ShowID=1349)

##分析

这里kmp和正常的kmp有些区别，pre[i]代表已经匹配了i个字符，第i+1个字符不匹配，应该回到怎样的j状态，j状态代表已经匹配了j+1个字符,pre[i]=-1表示回到没有匹配的状态，如果pre[i]=0表示已经匹配了第一个字符

```
void kmp()
{
    int i=0,j=-1;
    pre[0]=-1;
    while(i<l)
    {
        //先找到前面匹配的部分
        while(j>=0&&s[i]!=s[j])
        {
            j=pre[j];
        }
        //然后比较前缀相同的后面一个字符
        i++;
        j++;
        //如果后面一个字符相同，则说明刚刚产生的字符和s[j]也不相等，
        //所以要继续往前推（因为s[0..j]和s[i-j..i]的串完全相同，所以pre[i]==pre[j]）
        if(s[i]==s[j])
        {
            pre[i]=pre[j];
        }
        else
        {
            pre[i]=j;
        }
    }
}
```

pre[i]=j表示已经匹配了i个字符，第i+1个字符不比配应该回到j状态，j状态是指已经匹配到了j+1个字符，或者理解为了返回到下标为j的地方

e[i]表示从匹配i个字符到匹配i+1个字符的平均步数，e[0]代表没有匹配到匹配一个字符

`e[i] = 0.5*1+0.5*(1+e[pre[i]]+…+e[i])`（当前没有匹配上则需要的步数是1+e[pre[i]]+...+e[i]，以前只是e[pre[i]]+...+e[i]明显是错误的）

状态转移：0.5的概率直接一步到匹配i+1个字符，0.5的概率返回到匹配pre[i]个字符的状态

从0状态到匹配i个字符需要e[0]+e[1]+…+e[i-1]这么多步

```
sum[0]=e[0]=2;
for(int i=1;i<l;i++)
{
    e[i]=2;
    if(pre[i]==-1)
    {
        e[i]+=sum[i-1];
    }
    else
    {
        e[i]+=(sum[i-1]-sum[pre[i]]+N);
    }
    e[i]%=N;
    sum[i]=(e[i]+sum[i-1])%N;
}
```
