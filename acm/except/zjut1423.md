##题目

[地下迷宫](http://acm.zjut.edu.cn/ShowProblem.aspx?ShowID=1423)

##分析

根据概率列出等式，然后利用高斯消元的方法进行求解

高斯消元算法的思想：

```
n个未知数需要有n个方程，使用矩阵的方式进行记录
第一步：把第一列第一行保留，其他全部变成0
第二步：把第二列的第一行和第二行保留，其他全部变成0
………………
第n-1步：把第n-1列的第n行变成0
然后从下往上以此求解各个未知数
如果有两行是相同的，那么这个方程就无解了（回去看看线性代数秩之类的概念）
```

高斯消元代码实现思路：从第一列一直遍历到第n列，如果某一列全部为0则返回false说明没有解,否则比较一列中的所有行，看哪一行的最大把它换到最上面。

地下迷宫代码思想：记录开始和结束的位置，然后从开始点进行dfs，对遍历到的结点(I,j)用一个arr[i][j]标志成1，如果没有遍历到标志成0，如果不能到达

guass高斯消元一定要写对了,wa了n次主要是在交换两行的时候忘了把b[i]和b[index]也交换了

迷宫的四个走向：`int dir[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};`，然后判断格子是否合法

走迷宫一般都是dfs：

```
void dfs(int i, int j)
{
    if (!valid(i, j) || seq[i][j] != -1)
        return;

    seq[i][j] = N;
    ps[N].set(i, j);
    N++;
    for (int k = 0; k < 4; k++)
        dfs(i + dir[k][0], j + dir[k][1]);
}
```

这里是记录可达位置的序号，ps数组记录的是可达的位置。

高斯消元的思想：把第一列的第2-n行变成0，把第2列的3-n行变成0，把第n-1列的第n行变成0，然后从下往上分别解出x[n], x[n-1]…..x[1]

`seq[i][j]`：把一个点(i, j)映射成一个序号

迷宫的走法很简单：就是遍历周围的4个点，然后做标记

概率算法的构造：根据shihui的pdf文件，比较简单；把每个可达点设成一个未知数，然后根据可达点边的连接关系列出方程，比如1点可以到达2、3，则表示成`E(1) = 1/2*E(2) + 1/2 * E(3)+1`，最后一般求E(1)的值，E(i)表示i点到达出口的步数。而且已知出口点步数E(exit)=0。`seq[i][j]`相当于一个哈希表，把`(i,j)->seq[i][j]`

有时候查找可以构造哈希的方法，这样可能查找效率更快一些，只是浪费了一些空间
