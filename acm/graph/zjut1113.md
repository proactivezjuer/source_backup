##题目

[Stacking Boxes](http://acm.zjut.edu.cn/ShowProblem.aspx?ShowID=1113)

##分析

设有两个n维的箱子：箱子A（x1,x2,...,xn） 和箱子B(y1,y2,...,yn) ，设N={1,2,3,...,n} ，若对于i \in N, `xi<yi` ，则说箱子A可以嵌入到箱子B

题意：给定若干个箱子，找到最长的串b1b2...bk ，若`i<j`,bi可以嵌入bj ，若有长度相同的串取字典序最小的（所谓字典序最小的就是比较首序号大小，然后比较次序号大小，以此类推）

箱子的嵌入关系显然可以理解成图的有向边，而箱子可以理解成结点，这样输入可以形成一张图，然后查找有向图的最长路径即可（两两存在偏序之类的关系就可以理解成图）

图最长路径的求解方法（拓扑排序的思想）：

为每个结点 增加出度和入度，从入度为0的结点 开始遍历，采用bfs方法，到达结点 ，如果其出度为0，则说明到达了一条路径的终点，然后将当前路径的长度和原有最大长度比较，如果比原有长度更长，就更新原有的记录

```
tmp++
dfs(len)
tmp--
```

这种方法在dfs中非常普遍，还可以在有一个全局的数组记录遍历的每个结点。如果在dfs的过程中出现死胡同就会回溯，tmp就会重新回来，路径的记录也会返回，如果到达了出口点，就可以把数组和tmp进行记录。
